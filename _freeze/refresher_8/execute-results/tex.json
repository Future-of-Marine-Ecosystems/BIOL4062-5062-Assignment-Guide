{
  "hash": "63bf9c24e52e0507e7f33c988bcf7813",
  "result": {
    "engine": "knitr",
    "markdown": "# R Refresher Part 8: Programming Fundamentals\n\n***Created by Mauricio Cantor, with modifications by Laura J. Feyrer, Ana Eguiguren, and Reid Steele***\n\nThis section covers basic programming fundamentals in R, such as loops, user-defined functions, and if/else statements.\n\n*NOTE:* On refresher pages, some code lines will be commented out to avoid file structure issues surrounding saving files, downloading packages, and changing working directories.\n\n## User-defined functions\n\nIn addition to the functions included in base R and in packages, you can also create your own functions to help streamline and share your code (or even make your own package!). Functions are created using the `function()` command, with the syntax `function(arguments){code}`. Functions will refer to their arguments as variables internal to them, even if they do not exist in the environment. If they do exist in the environment, the function will prioritize its arguments before the global environment. Functions should almost always end in the `return()` command, which tells the function what to output when it is run.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 8. I. Programming fundamentals - Functions -----------------------------------\n\n\n# User-defined functions: function(){}\n# To create your own function, again, the recipe is the same: \n# create another object using pre-defined functions. What?\n# We will use a function called \"function()\" (boring, I know, but effective!).\n# For example, a very simple, but limited, function could be the one that sums 5 input values:\n# We will call it 'sum_5_numbers'\n\n\n\nsum_5_numbers <- function(value1, value2, value3, value4, value5){\n  \n  object <- value1 + value2 + value3 + value4 + value5\n  \n  return(object)\n}\n\n# What happened? R saved our function in the workspace\n# Note the structure: we give it a name, arguments (value1 to 5). It has internal objects (object) and it returns the sum of all arguments. Let's see if it works:\n\nsum_5_numbers(value1=10, value2=20, value3=30, value4=40, value5=50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 150\n```\n\n\n:::\n\n```{.r .cell-code}\nsum_5_numbers(3,6,90,1,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 102\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sweet! It did his job: summed 10+20+30+40+50.\n\n\n# use this for any formula that you apply frequently\n# ex: the vertical distance travelled by a free falling \n# object after x seconds\nd <- 1/2 *9.8 * 5^2\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 122.5\n```\n\n\n:::\n\n```{.r .cell-code}\nd2 <- 1/2 *9.8 * 2^2\n\ndist_fall <- function(time_sec){\n  d <- 1/2 *9.8 * time_sec^2\n  return(d)\n}\n\ndist_fall(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1960\n```\n\n\n:::\n\n```{.r .cell-code}\n#~~~~ A bit more complex functions----\n# It is good to have a workflow:\n# 1. design the steps of your process\n# 2. identify the inputs of your function\n# 3. change specific inputs to generic names\n# 4. add process into the body of your function\n\n\n\n\n# I want to simulate rolling a 6-faced dice once:\ndice <- seq(1:6)\nsample(dice, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# What about twice?\nsample(dice, 2, replace = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# How can I generalize this?\nn_rolls <- 7\nsample(dice, n_rolls, replace = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 4 6 6 6 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Put it in a function\ndice_rolling <- function(n_rolls){\n  results<-sample(dice, n_rolls, replace = T)\n  return(results)\n}\n\ndice_rolling(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 6 6 1 6 6 4 4 1 5 2 3 6 3 6 1 2 1 6 3 6 3 1 3 3 4 6 6 2 3 3 6 1 4 2 6 2 1\n [38] 5 6 2 2 4 2 3 2 4 3 6 1 6 4 3 6 6 2 4 4 1 6 4 6 6 3 1 2 5 5 4 1 6 2 3 2 3\n [75] 3 4 2 3 5 6 4 3 2 4 2 2 1 5 3 3 2 5 4 1 2 4 3 1 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# A function for a rolling dice in a game\n# in which you get 10 dollars each time you roll a six\nn_rolls <- 8\nwin_numb <- 6\nprice <- 0.10\n\ndice_rolling_money <- function(n_rolls, win_numb, price){\n  results <-sample(dice, n_rolls, replace = T)\n  money <- sum(results == win_numb)*price\n  return(list(results,money))\n}\n\n\ndice_rolling_money(5, 3, 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4 6 1 2 1\n\n[[2]]\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## for loops\n\n`for()` loops are coding structures designed to repeatedly execute code over a range. Their syntax is `for(index in range){code}`. When run, the `for()` loop will repeat the code with the value of the index variable (typically denoted `i`, but it can be anything) set to every value contained in the range.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 8. II. Programming fundamentals - For Loops -----------------------------------\n# used to repeat an action for i number of times\n# imagine I want to write sentence: today is (weekday)\n# for each of the week.\n# Initially you could try:\n\n\n# first making a vector that contains all weekdays\n\nweekday <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \n             \"Friday\", \"Saturday\", \"Sunday\")\n\n# then pasting it to \"today is\" for each one:\npaste(\"Today is\", weekday[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Monday\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# and I'd have to copy and paste this for each day of the week:\npaste(\"Today is\", weekday[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Tuesday\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Today is\", weekday[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Wednesday\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Today is\", weekday[4])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Thursday\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# etc...\n\n# When coding, we try to avoid copying and pasting things\n# more than twice because there is usually a more efficient\n# way of doing this. \n# One option is to use a for loop:\n\nfor(i in seq(1:7)){\n    print(paste(\"Today is\", weekday[i]))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Monday\"\n[1] \"Today is Tuesday\"\n[1] \"Today is Wednesday\"\n[1] \"Today is Thursday\"\n[1] \"Today is Friday\"\n[1] \"Today is Saturday\"\n[1] \"Today is Sunday\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# you can also save each of your results in a vector\nweekd_sent <- vector(length = 7)\n\nfor(i in seq(1:7)){\n  weekd_sent[i] <- (paste(\"Today is\", weekday[i]))\n}\n\nweekd_sent\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Monday\"    \"Today is Tuesday\"   \"Today is Wednesday\"\n[4] \"Today is Thursday\"  \"Today is Friday\"    \"Today is Saturday\" \n[7] \"Today is Sunday\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n# if you don't know the sequence lenth you can use the argument\n# seq_along()\nday_sentence <- vector(length = length(weekday)) # create an empty vector\n\nfor(i in seq_along(day_sentence)){\n  day_sentence[i]<- paste(\"Today is\", weekday[i])#carries operation for ith day\n}\n\nday_sentence\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Monday\"    \"Today is Tuesday\"   \"Today is Wednesday\"\n[4] \"Today is Thursday\"  \"Today is Friday\"    \"Today is Saturday\" \n[7] \"Today is Sunday\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n# RS Note: Some alternative ideas for the same thing\nday_sentence <- NULL\n\nfor(i in 1:length(weekday)){\n  day_sentence <- c(day_sentence, paste(\"Today is\", weekday[i]))#carries operation for ith day\n}\n\nday_sentence\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Today is Monday\"    \"Today is Tuesday\"   \"Today is Wednesday\"\n[4] \"Today is Thursday\"  \"Today is Friday\"    \"Today is Saturday\" \n[7] \"Today is Sunday\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n# This is very useful for processing files and making plots:\n# create an empty list to save each plot in a slot\nlibrary(dplyr) # package for filtering data\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2) #package for plotting\n\ndata(iris) # load iris dataset that comes in base R\nhead(iris) # see what is in there\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\n# I want to make one graph for each species:\n\nlevels(iris$Species) # how many species are there?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# create list with slot for each plot = species\np <- vector(\"list\", length = length(levels(iris$Species)))\n\n\nfor(i in seq(1:3)){\n  \n  subset_species <- iris %>% filter(Species == levels(iris$Species)[i])\n  p[[i]]<- ggplot(subset_species,\n         aes(x = Sepal.Length, y = Sepal.Width))+\n        geom_point()\n  \n}\n\nplot(p[[1]])\n```\n\n::: {.cell-output-display}\n![](refresher_8_files/figure-pdf/unnamed-chunk-2-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(p[[2]])\n```\n\n::: {.cell-output-display}\n![](refresher_8_files/figure-pdf/unnamed-chunk-2-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(p[[3]])\n```\n\n::: {.cell-output-display}\n![](refresher_8_files/figure-pdf/unnamed-chunk-2-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n## if, else, and ifelse\n\n`if()` statements are coding structures which are designed to perform an action only if a certain condition is met. Their syntax is `if(conditon){action}`, where the action is only carried out if the condition is `TRUE`. `else` is an extension of `if` which provides an alternate action to perform if the condition is false, using the syntax `if(conditon){action} else {alternative action}`. `ifelse()` is a function which compresses `if` and `else` together to be applied to vectors. Its syntax is `ifelse(conditon, value if true, value if false)`, where the condition must be a vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 8. III. Programming fundamentals - If Else  -----------------------------------\n# Perhaps you want parts of you code to run only when \n# satisfying some conditions. We then use a logical test.\n# if(): if(condition=true) do_command\n\nif(1 == 0) print(\"what?\")\nif(1 != 0) print(\"OK!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"OK!\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# ifelse(): if(condition=true, do_command1, do_command2_instead)\nifelse(1 == 0, print(\"no way!\"), print(\"OK!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"OK!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"OK!\"\n```\n\n\n:::\n\n```{.r .cell-code}\nifelse(1 != 0, print(\"all right!\"), print(\"what?!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"all right!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"all right!\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# RS Note - ifelse is vectorized, while if a scalar\n\n# if{}else{}: if(condition=true) {do_command1} else{do_command2_instead}\n# this is useful for long conditions or commands\nif (1 == 0 ){\n  print(\"are you crazy?\")\n} else {\n  print(\"OK!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"OK!\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# within a function:\n# Going back to the dice game, we can create similar game\n# in which you win if you roll the same number\n# two consecutive times\n# to keep it simple, we will only do this for 2 rolls\n\n#first I'll make \nn_rolls <- 2\n\ndice_rolling_pair <- function(n_rolls){\n  dice <- seq(1:6)\n  results <-sample(dice, n_rolls, replace = T)\n  if(results[1]==results[2]){print(\"win\")}else{\n    print(\"loose\")\n  }\n}\n\ndice_rolling_pair(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"loose\"\n```\n\n\n:::\n:::\n",
    "supporting": [
      "refresher_8_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}