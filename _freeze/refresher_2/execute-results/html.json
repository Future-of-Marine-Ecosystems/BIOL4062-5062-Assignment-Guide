{
  "hash": "91c8b0d7020cb2545d3d46e61dcd3af8",
  "result": {
    "engine": "knitr",
    "markdown": "# R Refresher Part 2: Types of Data and Data Structures\n\n***Created by Mauricio Cantor, with modifications by Laura J. Feyrer, Ana Eguiguren, and Reid Steele***\n\nThere are many different types of objects in R. This section is designed to introduce you to them, and the basics of how to work with them.\n\n*NOTE:* On refresher pages, some code lines will be commented out to avoid file structure issues surrounding saving files, downloading packages, and changing working directories.\n\n## Data Types\n\nR includes several different data types, all of which behave differently. The data type of an object can be checked using `class()`.\n\n### Numeric\n\nNumeric objects are numbers, which are used to perform arithmetic and associated mathematical functions. Other objects can be converted to numeric using `as.numeric()` and you can check if an object is numeric using `is.numeric()`. Integers are a subclass of numerics which lack decimals, and can be converted/checked using `as.integer()` and `is.integer()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Types of Data and Data Structures-----------------------------------------------------\n\n# There are many types of data structures in R: vectors, matrices, \n#dataframes, arrays, lists, functions etc.\n#that contain different types of data\n\n# 2.a) Types of Data -----\n# ~~~numeric \na <- c(2,4,7,8)\n\n# Check class\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert to character\ntest = as.character(a)\nas.numeric(test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# these are also integers\nis.integer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\na# prints the object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(a) #summarizes data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2.00    3.50    5.50    5.25    7.25    8.00 \n```\n\n\n:::\n\n```{.r .cell-code}\n# mathematical operations can be done:\na + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5 8 9\n```\n\n\n:::\n\n```{.r .cell-code}\na - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 6 7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(a)# get the average\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.25\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Character\n\nCharacter objects are text strings which are bound and created by `\"\"` or `''`. Mathematical functions do not work on them. Characters which contain only numerals can be translated to numerics as above, but will return `NA` if they contain anything other than a numeral. There is a wide range of functions designed to work on strings for a variety of purposes. Objects can be converted to character using `as.character()` or checked using `is.character`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~ character \nb <- c(\"hello\", \"goodbye\", \"goodbye\")\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"   \"goodbye\" \"goodbye\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n        3 character character \n```\n\n\n:::\n\n```{.r .cell-code}\n# doesn't allow for mathematical operations\nmean(b)# get the average\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(b): argument is not numeric or logical: returning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check the length of each\nnchar(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check if is a character\ntest # Note the quotation marks\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\" \"4\" \"7\" \"8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(test) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Substitution\nb_sub = gsub('good', '', b)\nb_sub\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"bye\"   \"bye\"  \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Factors\n\nFactors are categorical variables which are used to divide data into groups. They can be created using `factor()`, translated using `as.factor()`, and checked using `is.factor()`. In many (but not all) cases they behave similarly to characters, but they also have numeric elements. Each group inside a factor is called a level, and is assigned a numeric value, which is shown upon printing the factor.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~factor\n# factors act as categorical variables\nc <- as.factor(b)\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] hello   goodbye goodbye\nLevels: goodbye hello\n```\n\n\n:::\n\n```{.r .cell-code}\n# Levels can be set manually if a certain order is desired. They default to alphabetic/numeric order\nc = factor(b, levels = c('hello', 'goodbye'))\nc # Note the levels are different\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] hello   goodbye goodbye\nLevels: hello goodbye\n```\n\n\n:::\n\n```{.r .cell-code}\n# Arithmetic doesn't work\nmean(c)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(c): argument is not numeric or logical: returning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# as.numeric outputs the levels\nas.numeric(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Summary\nsummary(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hello goodbye \n      1       2 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Logicals\n\nLogicals are true or false. They can be created by various logical tests using Boolean operators such as `==`, `!=`, `>`, `<`, `<=`, and `>=`, or by logical functions such as those associated with `is`, including those listed above. They can be converted using `as.logical` and tested (logically!) using `is.logical`. Logicals can be written as `TRUE` or `FALSE` and `T` or `F` interchangeably. Numerically, logicals are binary, with `TRUE == 1` and `FALSE == 0`. This behaviour can be used to perform arithmetic on logicals.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~ logical\n# true or false variables\nd <- a == b\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in a == b: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Boolean tests\n1 > 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 < 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Mode   FALSE \nlogical       4 \n```\n\n\n:::\n\n```{.r .cell-code}\nmean(d)# logical operation converts F = 0, T = 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(d) # RS Note, you can use sum on logicals to get the number of TRUEs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# T and TRUE and F and FALSE are interchangeable\nT == TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Object Types\n\nIn addition to the different types of data, R has different types of objects to contain those different types of data:\n\n### Scalars\n\nA scalar is a single object, such as a single number, character string, or T/F. There are no functions specifically associated with scalars. They are treated as vectors of length 1.\n\n### Vectors\n\nA vector is a one-dimensional sequence of values. Vectors can be of any data type. They are created using `c()`, and can be converted using `as.vector()` and tested using `is.vector()`. The number of elements in a vector can be determined using `length()`. Vectors are indexed using `[]` (see refresher section 4 for more). By default in R, performing a function on a vector applies it to all elements of the vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2.b) Types of objects -------\n\n# different data types can be stored in different objects\n# ~~~ Vector: one-dimensional sequence of values\n\n# it can have numbers, characters, etc\nnum_vector <- c(3,6,9,12,15)\nnum_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6  9 12 15\n```\n\n\n:::\n\n```{.r .cell-code}\n# check the length\nlength(num_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Indexing\nnum_vector[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnum_vector[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Operations are applied to all elements\nnum_vector+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  7 10 13 16\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(num_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(num_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"  \"6\"  \"9\"  \"12\" \"15\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# character vectors\nchar_vector <- c(\"Data\", \"analysis\", \"fun\")\nchar_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Data\"     \"analysis\" \"fun\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nchar_vector2 <- c(\"Data\", \"analysis\", 1)\n# when we mix character with numbers, everything becomes character\nchar_vector2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Data\"     \"analysis\" \"1\"       \n```\n\n\n:::\n\n```{.r .cell-code}\n#check data class stored within a vector:\ndata.class(char_vector2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndata.class(num_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# A scalar is a vector of 1\nis.vector(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Matrices\n\nMatrices are basic two-dimensional data structures. Matrices are almost always numeric. Unlike data frames, matrices can only contain one data type. Matrices can be created using `matrix()`, translated using `as.matrix()`, and tested using `is.matrix()`. Matrices are indexed using `[row,column]` (see refresher section 4 for more).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~ Matrix and data frames: 2 dimensions\n# matrices are usually numerical\n\n#calls for data, n rows, n cols\nmy_matrix1 <-  matrix(1:6, 2, 3, byrow = T)# data, rows, columns\nmy_matrix2 <-  rbind(num_vector, num_vector) # or 'rbind()', 'cbind()' and others; RS Note, column names must be the same\nmy_matrix3 <-  cbind(my_matrix2, my_matrix2) # or 'rbind()', 'cbind()' and others\n\n# Character matrix\nmatrix(c('a', 'b', 'c', 'd', 'e', 'f'), nrow = 2, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# Mixing makes everything character\nmatrix(c('a', 'b', 'c', 'd', 2, 3), nrow = 2, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"2\" \n[2,] \"b\"  \"d\"  \"3\" \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Data Frames\n\nData frames are the workhorse two-dimensional data structures in R. Think of them like a standard table. Unlike matrices, each column in a data frame can be a different data type. Data frames can be indexed using `[row,column]` or `$column` (see refresher section 4 for more). Data frames are made using `data.frame()`, translated using `as.data.frame()`, and checked using `is.data.frame()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~ data.frames can contain numbers, characters or both\nmy_df <- data.frame(test = char_vector, char_vector2)\nmy_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      test char_vector2\n1     Data         Data\n2 analysis     analysis\n3      fun            1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Column names can be set with names() or colnames()\nnames(my_df) <- c(\"name\", \"order\")\nmy_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name    order\n1     Data     Data\n2 analysis analysis\n3      fun        1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Basic indexing\nmy_df[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Data\"     \"analysis\" \"fun\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nmy_df$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Data\"     \"analysis\" \"fun\"     \n```\n\n\n:::\n\n```{.r .cell-code}\n# Translate a matrix\nmy_matrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nas.data.frame(my_matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  V1 V2 V3\n1  1  2  3\n2  4  5  6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Lists\n\nLists are more freeform data structures in R which can be used to contain multiples of anything. Lists tend to be a bit more difficult to work with than other data types. They are indexed using `[[]]`, created using `list()`, translated using `as.list()` and checked using `is.list()`. Technically, data frames are a special type of list.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~~~ lists are multidimensional objects of anything \n# with any dimension\nmy_list <- list(a, num_vector, char_vector, my_df)\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2 4 7 8\n\n[[2]]\n[1]  3  6  9 12 15\n\n[[3]]\n[1] \"Data\"     \"analysis\" \"fun\"     \n\n[[4]]\n      name    order\n1     Data     Data\n2 analysis analysis\n3      fun        1\n```\n\n\n:::\n\n```{.r .cell-code}\n#lists hold each of the elements in a \"slot\"\n# These slosts can be indexed using [[]]\nmy_list[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6  9 12 15\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list[[2]][1] # We can stack square brackets to go deeper into a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# A data frame is a type of list\nis.list(my_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Tibbles\n\nThere are a few other types of more niche data structures you may come across, such as arrays and data tables. The most notable of these is the tibble - a special form of data frame which hails from the tidyverse. Tibbles print differently from data frames, and they have some unique properties which don't always play nice with other functions. It's good to know about them, and how to change them back to data frames if you run into such a situation.\n\nTibbles are usually created by using a `dplyr` or `tidyr` function on a data frame, but can also be created by `tibble()`. They can be translated back to data frames using `as.data.frame()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tibbles look a little different, particularly when printing large tibbles as compared to large data frames in the console\nmy_tibble = tibble::tibble(my_df)\nmy_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n  name     order   \n  <chr>    <chr>   \n1 Data     Data    \n2 analysis analysis\n3 fun      1       \n```\n\n\n:::\n\n```{.r .cell-code}\n# Tibbles can be translated back using as.data.frame if required\nas.data.frame(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name    order\n1     Data     Data\n2 analysis analysis\n3      fun        1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Useful functions\n\nBelow you can see some useful functions for dealing with data and object types. Play around and get to know them.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2.c) useful functions for object types----\n#2 ~~~ figuring data types and structure\nclass(my_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndata.class(my_df) #synonyms to classify data type or object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx = 2; class(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(my_df) # see components of an object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  2 variables:\n $ name : chr  \"Data\" \"analysis\" \"fun\"\n $ order: chr  \"Data\" \"analysis\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(my_df) # summarize each of the components of an object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     name              order          \n Length:3           Length:3          \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : num [1:4] 2 4 7 8\n $ : num [1:5] 3 6 9 12 15\n $ : chr [1:3] \"Data\" \"analysis\" \"fun\"\n $ :'data.frame':\t3 obs. of  2 variables:\n  ..$ name : chr [1:3] \"Data\" \"analysis\" \"fun\"\n  ..$ order: chr [1:3] \"Data\" \"analysis\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Length Class      Mode     \n[1,] 4      -none-     numeric  \n[2,] 5      -none-     numeric  \n[3,] 3      -none-     character\n[4,] 2      data.frame list     \n```\n\n\n:::\n\n```{.r .cell-code}\nobject <- c(1:10)\n\nlength(object) # number of elements or components\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nc(object,object) # combine objects into a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\ncbind(object, object) # combine objects as columns into an array (NOT A DATA FRAME UNLESS ONE OR BOTH INPUTS ARE DATA FRAMES!)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      object object\n [1,]      1      1\n [2,]      2      2\n [3,]      3      3\n [4,]      4      4\n [5,]      5      5\n [6,]      6      6\n [7,]      7      7\n [8,]      8      8\n [9,]      9      9\n[10,]     10     10\n```\n\n\n:::\n\n```{.r .cell-code}\nrbind(object, object) # combine objects as rows into an array (NOT A DATA FRAME UNLESS ONE OR BOTH INPUTS ARE DATA FRAMES!)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nobject    1    2    3    4    5    6    7    8    9    10\nobject    1    2    3    4    5    6    7    8    9    10\n```\n\n\n:::\n\n```{.r .cell-code}\nobject     # prints the object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(object) #removes object from environment\nobject\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'object' not found\n```\n\n\n:::\n:::\n",
    "supporting": [
      "refresher_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}